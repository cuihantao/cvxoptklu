

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The LAPACK Interface &mdash; CVXOPT User&#39;s Guide</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
        <link rel="copyright" title="Copyright" href="copyright.html"/>
    <link rel="top" title="CVXOPT User&#39;s Guide" href="index.html"/>
        <link rel="next" title="Discrete Transforms" href="fftw.html"/>
        <link rel="prev" title="The BLAS Interface" href="blas.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> CVXOPT User's Guide</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrices.html">Dense and Sparse Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#dense-matrices">Dense Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#sparse-matrices">Sparse Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#arithmetic-operations">Arithmetic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#indexing-and-slicing">Indexing and Slicing</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#attributes-and-methods">Attributes and Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#built-in-functions">Built-In Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#other-matrix-functions">Other Matrix Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#randomly-generated-matrices">Randomly Generated Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">The BLAS Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="blas.html#matrix-classes">Matrix Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="blas.html#level-1-blas">Level 1 BLAS</a></li>
<li class="toctree-l2"><a class="reference internal" href="blas.html#level-2-blas">Level 2 BLAS</a></li>
<li class="toctree-l2"><a class="reference internal" href="blas.html#level-3-blas">Level 3 BLAS</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">The LAPACK Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-linear-equations">General Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#positive-definite-linear-equations">Positive Definite Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symmetric-and-hermitian-linear-equations">Symmetric and Hermitian Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#triangular-linear-equations">Triangular Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#least-squares-and-least-norm-problems">Least-Squares and Least-Norm Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symmetric-and-hermitian-eigenvalue-decomposition">Symmetric and Hermitian Eigenvalue Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generalized-symmetric-definite-eigenproblems">Generalized Symmetric Definite Eigenproblems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#singular-value-decomposition">Singular Value Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#schur-and-generalized-schur-factorization">Schur and Generalized Schur Factorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-analytic-centering">Example: Analytic Centering</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="fftw.html">Discrete Transforms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="fftw.html#discrete-fourier-transform">Discrete Fourier Transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="fftw.html#discrete-cosine-transform">Discrete Cosine Transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="fftw.html#discrete-sine-transform">Discrete Sine Transform</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spsolvers.html">Sparse Linear Equations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spsolvers.html#matrix-orderings">Matrix Orderings</a></li>
<li class="toctree-l2"><a class="reference internal" href="spsolvers.html#general-linear-equations">General Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="spsolvers.html#positive-definite-linear-equations">Positive Definite Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="spsolvers.html#example-covariance-selection">Example: Covariance Selection</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="coneprog.html">Cone Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#linear-cone-programs">Linear Cone Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#quadratic-cone-programs">Quadratic Cone Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#linear-programming">Linear Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#quadratic-programming">Quadratic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#second-order-cone-programming">Second-Order Cone Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#semidefinite-programming">Semidefinite Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#exploiting-structure">Exploiting Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#optional-solvers">Optional Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#algorithm-parameters">Algorithm Parameters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solvers.html">Nonlinear Convex Optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#problems-with-nonlinear-objectives">Problems with Nonlinear Objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#problems-with-linear-objectives">Problems with Linear Objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#geometric-programming">Geometric Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#exploiting-structure">Exploiting Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#algorithm-parameters">Algorithm Parameters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#constraints">Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#optimization-problems">Optimization Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">C API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="c-api.html#dense-matrices">Dense Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="c-api.html#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="printing.html">Matrix Formatting</a></li>
<li class="toctree-l1"><a class="reference external" href="http://cvxopt.org">cvxopt.org</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">CVXOPT User's Guide</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>The LAPACK Interface</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="the-lapack-interface">
<span id="c-lapack"></span><h1>The LAPACK Interface<a class="headerlink" href="#the-lapack-interface" title="Permalink to this headline">¶</a></h1>
<p>The module <code class="xref py py-mod docutils literal"><span class="pre">cvxopt.lapack</span></code> includes functions for solving dense sets
of linear equations, for the corresponding matrix factorizations (LU,
Cholesky, <span class="raw-html">LDL<sup><small>T</small></sup></span>),
for solving least-squares and least-norm problems, for
QR factorization, for symmetric eigenvalue problems, singular value
decomposition, and Schur factorization.</p>
<p>In this chapter we briefly describe the Python calling sequences.  For
further details on the underlying LAPACK functions we refer to the LAPACK
Users&#8217; Guide and manual pages.</p>
<p>The BLAS conventional storage scheme of the section <a class="reference internal" href="blas.html#s-conventions"><span>Matrix Classes</span></a>
is used. As in the previous chapter, we omit from the function definitions
less important arguments that are useful for selecting submatrices.  The
complete definitions are documented in the docstrings in the source code.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://www.netlib.org/lapack/lug/lapack_lug.html">LAPACK Users&#8217; Guide, Third Edition, SIAM, 1999</a></p>
</div>
<div class="section" id="general-linear-equations">
<h2>General Linear Equations<a class="headerlink" href="#general-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.gesv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gesv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>ipiv = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gesv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/f653e38f1855f52cb4db07a7a9fcf43d99337b25.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> are real or complex matrices, with
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> square and nonsingular.</p>
<p>The arguments <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code>
or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  On entry, <code class="docutils literal"><span class="pre">B</span></code>  contains the right-hand side
<img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.  The optional
argument <code class="docutils literal"><span class="pre">ipiv</span></code> is an integer matrix of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.
If <code class="docutils literal"><span class="pre">ipiv</span></code> is provided, then <code class="xref py py-func docutils literal"><span class="pre">gesv</span></code> solves the system, replaces
<code class="docutils literal"><span class="pre">A</span></code> with the triangular factors in an LU factorization, and returns
the permutation matrix in <code class="docutils literal"><span class="pre">ipiv</span></code>.  If <code class="docutils literal"><span class="pre">ipiv</span></code> is not specified,
then <code class="xref py py-func docutils literal"><span class="pre">gesv</span></code> solves the system but does not return the LU
factorization and does not modify <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.getrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">getrf</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.getrf" title="Permalink to this definition">¶</a></dt>
<dd><p>LU factorization of a general, possibly rectangular, real or
complex matrix,</p>
<div class="math">
<p><img src="_images/math/bbe3c7674803b8326dfc8b4b1ba88c675de5721d.png" alt="A = PLU,"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p>The argument <code class="docutils literal"><span class="pre">ipiv</span></code> is an integer matrix of length at least
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.  On exit, the lower triangular part of
<code class="docutils literal"><span class="pre">A</span></code> is replaced by <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/>, the upper triangular part by <img class="math" src="_images/math/73f5e249c88b2b3068263480f576b051cb5c4f6e.png" alt="U"/>,
and the permutation matrix is returned in <code class="docutils literal"><span class="pre">ipiv</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is not full rank.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.getrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">getrs</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.getrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a general set of linear equations</p>
<div class="math">
<p><img src="_images/math/eb3d9f0698c7f5c1906c4d26b8fcf1f315e74318.png" alt="AX &amp; = B  \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>given the LU factorization computed by
<a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal"><span class="pre">gesv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.getrf" title="cvxopt.lapack.getrf"><code class="xref py py-func docutils literal"><span class="pre">getrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> must contain the factorization as computed
by <code class="xref py py-func docutils literal"><span class="pre">gesv</span></code> or <code class="xref py py-func docutils literal"><span class="pre">getrf</span></code>.  On entry, <code class="docutils literal"><span class="pre">B</span></code> contains the
right-hand side <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.
<code class="docutils literal"><span class="pre">B</span></code> must have the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.getri">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">getri</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.getri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a matrix.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> must contain the factorization as computed
by <a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal"><span class="pre">gesv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.getrf" title="cvxopt.lapack.getrf"><code class="xref py py-func docutils literal"><span class="pre">getrf</span></code></a>.  On exit, <code class="docutils literal"><span class="pre">A</span></code> contains the
matrix inverse.</p>
</dd></dl>

<p>In the following example we compute</p>
<div class="math">
<p><img src="_images/math/4686c6013ea687f6a5b2fb37cd87d9298c5fe5d8.png" alt="x = (A^{-1} + A^{-T})b"/></p>
</div><p>for randomly generated problem data, factoring the coefficient matrix once.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">gesv</span><span class="p">,</span> <span class="n">getrs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipiv</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gesv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">)</span>               <span class="c"># x = A^{-1}*b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getrs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>  <span class="c"># x2 = A^{-T}*b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="n">x2</span>
</pre></div>
</div>
<p>Separate functions are provided for equations with band matrices.</p>
<dl class="function">
<dt id="cvxopt.lapack.gbsv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gbsv</code><span class="sig-paren">(</span><em>A</em>, <em>kl</em>, <em>B</em><span class="optional">[</span>, <em>ipiv = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gbsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/f653e38f1855f52cb4db07a7a9fcf43d99337b25.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> are real or complex matrices, with
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and banded with <img class="math" src="_images/math/92d23ba3d0cf03e961e3c70407948e15a3239435.png" alt="k_l"/>
subdiagonals.</p>
<p>The arguments <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code>
or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  On entry, <code class="docutils literal"><span class="pre">B</span></code> contains the right-hand side
<img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.  The optional
argument <code class="docutils literal"><span class="pre">ipiv</span></code> is an integer matrix of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.
If <code class="docutils literal"><span class="pre">ipiv</span></code> is provided, then <code class="docutils literal"><span class="pre">A</span></code> must have <img class="math" src="_images/math/e88d7235397bfea3fbb0fb4e7680407acdb79f87.png" alt="2k_l + k_u + 1"/>
rows.  On entry the diagonals of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> are stored in rows
<img class="math" src="_images/math/59c706ea5c074f4fd2d3fc9f17d7ac3d276dc84f.png" alt="k_l + 1"/> to <img class="math" src="_images/math/e88d7235397bfea3fbb0fb4e7680407acdb79f87.png" alt="2k_l + k_u + 1"/> of <code class="docutils literal"><span class="pre">A</span></code>, using the BLAS
format for general band matrices (see the section
<a class="reference internal" href="blas.html#s-conventions"><span>Matrix Classes</span></a>).  On exit, the factorization is returned in
<code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code>.  If <code class="docutils literal"><span class="pre">ipiv</span></code> is not provided, then <code class="docutils literal"><span class="pre">A</span></code> must have
<img class="math" src="_images/math/faba65ef70827bc1839211eafd2d9573b6aa64b0.png" alt="k_l + k_u + 1"/> rows.  On entry the diagonals of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> are
stored in the rows of <code class="docutils literal"><span class="pre">A</span></code>, following the standard BLAS format for
general band matrices.  In this case, <code class="xref py py-func docutils literal"><span class="pre">gbsv</span></code> does not modify
<code class="docutils literal"><span class="pre">A</span></code> and does not return the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.gbtrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gbtrf</code><span class="sig-paren">(</span><em>A</em>, <em>m</em>, <em>kl</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gbtrf" title="Permalink to this definition">¶</a></dt>
<dd><p>LU factorization of a general <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> real or complex
band matrix with <img class="math" src="_images/math/92d23ba3d0cf03e961e3c70407948e15a3239435.png" alt="k_l"/> subdiagonals.</p>
<p>The matrix is stored using the BLAS format for general band matrices
(see the section <a class="reference internal" href="blas.html#s-conventions"><span>Matrix Classes</span></a>), by providing the diagonals
(stored as rows of a <img class="math" src="_images/math/50e0b32054a553f10d8a402909d4bfd04ff51197.png" alt="k_u + k_l + 1"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrix <code class="docutils literal"><span class="pre">A</span></code>),
the number of rows <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, and the number of subdiagonals
<img class="math" src="_images/math/92d23ba3d0cf03e961e3c70407948e15a3239435.png" alt="k_l"/>.  The argument <code class="docutils literal"><span class="pre">ipiv</span></code> is an integer matrix of length at
least min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.  On exit, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> contain
the details of the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is not full rank.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.gbtrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gbtrs</code><span class="sig-paren">(</span><em>{A</em>, <em>kl</em>, <em>ipiv</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gbtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/aa6d78ef03e72bc807167e84142a6f9cf0e6860d.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>with <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> a general band matrix with <img class="math" src="_images/math/92d23ba3d0cf03e961e3c70407948e15a3239435.png" alt="k_l"/> subdiagonals,
given the LU factorization computed by
<a class="reference internal" href="#cvxopt.lapack.gbsv" title="cvxopt.lapack.gbsv"><code class="xref py py-func docutils literal"><span class="pre">gbsv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.gbtrf" title="cvxopt.lapack.gbtrf"><code class="xref py py-func docutils literal"><span class="pre">gbtrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> must contain the factorization as computed
by <code class="xref py py-func docutils literal"><span class="pre">gbsv</span></code> or <code class="xref py py-func docutils literal"><span class="pre">gbtrf</span></code>.  On entry, <code class="docutils literal"><span class="pre">B</span></code> contains the
right-hand side <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.
<code class="docutils literal"><span class="pre">B</span></code> must have the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<p>As an example, we solve a linear equation with</p>
<div class="math">
<p><img src="_images/math/95eb42a74083f3034ef47412f7b8b9c91f4292b5.png" alt="A = \left[ \begin{array}{cccc}
    1 &amp; 2 &amp; 0 &amp; 0 \\
    3 &amp; 4 &amp; 5 &amp; 0 \\
    6 &amp; 7 &amp; 8 &amp; 9 \\
    0 &amp; 10 &amp; 11 &amp; 12
    \end{array}\right], \qquad
B = \left[\begin{array}{c} 1 \\ 1 \\ 1 \\ 1 \end{array}\right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">gbsv</span><span class="p">,</span> <span class="n">gbtrf</span><span class="p">,</span> <span class="n">gbtrs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ku</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">12.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbsv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 4.64e-01]</span>
<span class="go">[-2.14e-01]</span>
<span class="go">[-1.07e-01]</span>
</pre></div>
</div>
<p>The code below illustrates how one can reuse the factorization returned
by <a class="reference internal" href="#cvxopt.lapack.gbsv" title="cvxopt.lapack.gbsv"><code class="xref py py-func docutils literal"><span class="pre">gbsv</span></code></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Ac</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kl</span><span class="o">+</span><span class="n">ku</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ac</span><span class="p">[</span><span class="n">kl</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipiv</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbsv</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">)</span>                 <span class="c"># solves A*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 4.64e-01]</span>
<span class="go">[-2.14e-01]</span>
<span class="go">[-1.07e-01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrs</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>     <span class="c"># solve A^T*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 2.38e-02]</span>
<span class="go">[ 1.43e-01]</span>
<span class="go">[-2.38e-02]</span>
</pre></div>
</div>
<p>An alternative method uses <a class="reference internal" href="#cvxopt.lapack.gbtrf" title="cvxopt.lapack.gbtrf"><code class="xref py py-func docutils literal"><span class="pre">gbtrf</span></code></a> for the
factorization.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Ac</span><span class="p">[</span><span class="n">kl</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrf</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrs</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                <span class="c"># solve A^T*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 4.64e-01]</span>
<span class="go">[-2.14e-01]</span>
<span class="go">[-1.07e-01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrs</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>     <span class="c"># solve A^T*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 2.38e-02]</span>
<span class="go">[ 1.43e-01]</span>
<span class="go">[-2.38e-02]</span>
</pre></div>
</div>
<p>The following functions can be used for tridiagonal matrices. They use a
simpler matrix format, with the diagonals stored in three separate vectors.</p>
<dl class="function">
<dt id="cvxopt.lapack.gtsv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gtsv</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em>, <em>B)</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gtsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/f653e38f1855f52cb4db07a7a9fcf43d99337b25.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> tridiagonal matrix.</p>
<p>The subdiagonal of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is stored as a matrix <code class="docutils literal"><span class="pre">dl</span></code> of length
<img class="math" src="_images/math/ec9a814a8db8511dd6afe998d946e72bb79ae20c.png" alt="n-1"/>, the diagonal is stored as a matrix <code class="docutils literal"><span class="pre">d</span></code> of length
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, and the superdiagonal is stored as a matrix <code class="docutils literal"><span class="pre">du</span></code> of
length <img class="math" src="_images/math/ec9a814a8db8511dd6afe998d946e72bb79ae20c.png" alt="n-1"/>.  The four arguments must have the same type
(<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  On exit <code class="docutils literal"><span class="pre">dl</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, <code class="docutils literal"><span class="pre">du</span></code> are
overwritten with the details of the LU factorization of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.
On entry, <code class="docutils literal"><span class="pre">B</span></code> contains the right-hand side <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>; on exit it
contains the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.gttrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gttrf</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em>, <em>du2</em>, <em>ipiv</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gttrf" title="Permalink to this definition">¶</a></dt>
<dd><p>LU factorization of an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> tridiagonal matrix.</p>
<p>The subdiagonal of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is stored as a matrix <code class="docutils literal"><span class="pre">dl</span></code> of length
<img class="math" src="_images/math/ec9a814a8db8511dd6afe998d946e72bb79ae20c.png" alt="n-1"/>, the diagonal is stored as a matrix <code class="docutils literal"><span class="pre">d</span></code> of length
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, and the superdiagonal is stored as a matrix <code class="docutils literal"><span class="pre">du</span></code> of length
<img class="math" src="_images/math/ec9a814a8db8511dd6afe998d946e72bb79ae20c.png" alt="n-1"/>.  <code class="docutils literal"><span class="pre">dl</span></code>, <code class="docutils literal"><span class="pre">d</span></code> and <code class="docutils literal"><span class="pre">du</span></code> must have the same type.
<code class="docutils literal"><span class="pre">du2</span></code> is a matrix of length <img class="math" src="_images/math/573f1dbd55f7a60f53088d2ebc1c19b6d9d20e29.png" alt="n-2"/>, and of the same type as
<code class="docutils literal"><span class="pre">dl</span></code>.  <code class="docutils literal"><span class="pre">ipiv</span></code> is an <code class="xref py py-const docutils literal"><span class="pre">'i'</span></code> matrix of length <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.
On exit, the five arguments contain the details of the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.gttrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gttrs</code><span class="sig-paren">(</span><em>dl</em>, <em>d</em>, <em>du</em>, <em>du2</em>, <em>ipiv</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/aa6d78ef03e72bc807167e84142a6f9cf0e6860d.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> tridiagonal matrix.</p>
<p>The arguments <code class="docutils literal"><span class="pre">dl</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, <code class="docutils literal"><span class="pre">du</span></code>, <code class="docutils literal"><span class="pre">du2</span></code>, and <code class="docutils literal"><span class="pre">ipiv</span></code> contain
the details of the LU factorization as returned by
<a class="reference internal" href="#cvxopt.lapack.gttrf" title="cvxopt.lapack.gttrf"><code class="xref py py-func docutils literal"><span class="pre">gttrf</span></code></a>.
On entry, <code class="docutils literal"><span class="pre">B</span></code> contains the right-hand side <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>; on exit it
contains the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.  <code class="docutils literal"><span class="pre">B</span></code> must have the same type as
the other arguments.</p>
</dd></dl>

</div>
<div class="section" id="positive-definite-linear-equations">
<h2>Positive Definite Linear Equations<a class="headerlink" href="#positive-definite-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.posv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">posv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.posv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/f653e38f1855f52cb4db07a7a9fcf43d99337b25.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is a real symmetric or complex Hermitian positive
definite matrix.</p>
<p>On exit, <code class="docutils literal"><span class="pre">B</span></code> is replaced by the solution, and <code class="docutils literal"><span class="pre">A</span></code> is overwritten
with the Cholesky factor.  The matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> must have
the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.potrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">potrf</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.potrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cholesky factorization</p>
<div class="math">
<p><img src="_images/math/8eda42f47290c234d1bff18ec887dcf1078a45ba.png" alt="A = LL^T \qquad \mbox{or} \qquad A = LL^H"/></p>
</div><p>of a positive definite real symmetric or complex Hermitian matrix
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<p>On exit, the lower triangular part of <code class="docutils literal"><span class="pre">A</span></code> (if <code class="docutils literal"><span class="pre">uplo</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">'L'</span></code>) or the upper triangular part (if <code class="docutils literal"><span class="pre">uplo</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">'U'</span></code>) is overwritten with the Cholesky factor or its
(conjugate) transpose.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.potrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">potrs</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.potrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/1beb2d429fd60d4494135aa7af1b4fe324dc8d3d.png" alt="AX = B"/></p>
</div><p>with a positive definite real symmetric or complex Hermitian matrix,
given the Cholesky factorization computed by
<a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal"><span class="pre">posv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.potrf" title="cvxopt.lapack.potrf"><code class="xref py py-func docutils literal"><span class="pre">potrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> contains the triangular factor, as computed by
<code class="xref py py-func docutils literal"><span class="pre">posv</span></code> or <code class="xref py py-func docutils literal"><span class="pre">potrf</span></code>.  On exit, <code class="docutils literal"><span class="pre">B</span></code> is replaced by the
solution.  <code class="docutils literal"><span class="pre">B</span></code> must have the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.potri">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">potri</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.potri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a positive definite matrix.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> contains the Cholesky factorization computed by
<a class="reference internal" href="#cvxopt.lapack.potri" title="cvxopt.lapack.potri"><code class="xref py py-func docutils literal"><span class="pre">potrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal"><span class="pre">posv</span></code></a>.  On exit, it contains the matrix
inverse.</p>
</dd></dl>

<p>As an example, we use <a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal"><span class="pre">posv</span></code></a> to solve the
linear system</p>
<div class="math" id="equation-e-kkt-example">
<p><span class="eqno">(1)</span><img src="_images/math/d2ac2e45e520f9ba6c24cc8087486cf69552fcff.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\left[ \begin{array}{cc}
    -\diag(d)^2  &amp; A \\ A^T  &amp; 0
\end{array} \right]
\left[ \begin{array}{c} x_1 \\ x_2 \end{array} \right]
=
\left[ \begin{array}{c} b_1 \\ b_2 \end{array} \right]"/></p>
</div><p>by block-elimination.  We first pick a random problem.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">uniform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.blas</span> <span class="kn">import</span> <span class="n">syrk</span><span class="p">,</span> <span class="n">gemv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">posv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>We then solve the equations</p>
<div class="math">
<p><img src="_images/math/3c8db3ccd634c824b36b6a922439b35ed2e0c84e.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\begin{split}
A^T \diag(d)^{-2}A x_2 &amp; = b_2 + A^T \diag(d)^{-2} b_1 \\
\diag(d)^2 x_1 &amp; = Ax_2 - b_1.
\end{split}"/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Asc</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">[:,</span> <span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>                <span class="c"># Asc := diag(d)^{-1}*A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">syrk</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>                  <span class="c"># B := Asc^T * Asc = A^T * diag(d)^{-2} * A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>                          <span class="c"># x1 := diag(d)^{-1}*b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="o">+</span><span class="n">b2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemv</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>   <span class="c"># x2 := x2 + Asc^T*x1 = b2 + A^T*diag(d)^{-2}*b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">posv</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>                              <span class="c"># x2 := B^{-1}*x2 = B^{-1}*(b2 + A^T*diag(d)^{-2}*b1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemv</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>             <span class="c"># x1 := Asc*x2 - x1 = diag(d)^{-1} * (A*x2 - b1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>                          <span class="c"># x1 := diag(d)^{-1}*x1 = diag(d)^{-2} * (A*x2 - b1)</span>
</pre></div>
</div>
<p>There are separate routines for equations with positive definite band
matrices.</p>
<dl class="function">
<dt id="cvxopt.lapack.pbsv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">pbsv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>uplo='L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pbsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/1beb2d429fd60d4494135aa7af1b4fe324dc8d3d.png" alt="AX = B"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is a real symmetric or complex Hermitian positive
definite band matrix.</p>
<p>On entry, the diagonals of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> are stored in <code class="docutils literal"><span class="pre">A</span></code>, using the
BLAS format for symmetric or Hermitian band matrices (see
section <a class="reference internal" href="blas.html#s-conventions"><span>Matrix Classes</span></a>).  On exit, <code class="docutils literal"><span class="pre">B</span></code> is replaced by the
solution, and <code class="docutils literal"><span class="pre">A</span></code> is overwritten with the Cholesky factor (in the
BLAS format for triangular band matrices).  The matrices <code class="docutils literal"><span class="pre">A</span></code> and
<code class="docutils literal"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.pbtrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">pbtrf</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pbtrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cholesky factorization</p>
<div class="math">
<p><img src="_images/math/8eda42f47290c234d1bff18ec887dcf1078a45ba.png" alt="A = LL^T \qquad \mbox{or} \qquad A = LL^H"/></p>
</div><p>of a positive definite real symmetric or complex Hermitian band matrix
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<p>On entry, the diagonals of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> are stored in <code class="docutils literal"><span class="pre">A</span></code>, using the
BLAS format for symmetric or Hermitian band matrices.  On exit, <code class="docutils literal"><span class="pre">A</span></code>
contains the Cholesky factor, in the BLAS format for triangular band
matrices.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.pbtrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">pbtrs</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pbtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/a1bc13b30be9e9dfe869a53a7765a333f0a7d3b5.png" alt="AX=B"/></p>
</div><p>with a positive definite real symmetric or complex Hermitian band
matrix, given the Cholesky factorization computed by
<a class="reference internal" href="#cvxopt.lapack.pbsv" title="cvxopt.lapack.pbsv"><code class="xref py py-func docutils literal"><span class="pre">pbsv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.pbtrf" title="cvxopt.lapack.pbtrf"><code class="xref py py-func docutils literal"><span class="pre">pbtrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> contains the triangular factor, as computed by
<code class="xref py py-func docutils literal"><span class="pre">pbsv</span></code> or <code class="xref py py-func docutils literal"><span class="pre">pbtrf</span></code>.  On exit, <code class="docutils literal"><span class="pre">B</span></code> is replaced by the
solution.  <code class="docutils literal"><span class="pre">B</span></code> must have the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<p>The following functions are useful for tridiagonal systems.</p>
<dl class="function">
<dt id="cvxopt.lapack.ptsv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">ptsv</code><span class="sig-paren">(</span><em>d</em>, <em>e</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ptsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/f653e38f1855f52cb4db07a7a9fcf43d99337b25.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> positive definite real
symmetric or complex Hermitian tridiagonal matrix.</p>
<p>The diagonal of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is stored as a <code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> matrix <code class="docutils literal"><span class="pre">d</span></code> of
length <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and its subdiagonal as a <code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>
matrix <code class="docutils literal"><span class="pre">e</span></code> of length <img class="math" src="_images/math/ec9a814a8db8511dd6afe998d946e72bb79ae20c.png" alt="n-1"/>.  The arguments <code class="docutils literal"><span class="pre">e</span></code> and <code class="docutils literal"><span class="pre">B</span></code>
must have the same type.  On exit <code class="docutils literal"><span class="pre">d</span></code> contains the diagonal elements
of <img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/> in the
<span class="raw-html">LDL<sup><small>T</small></sup></span>
or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>, and
<code class="docutils literal"><span class="pre">e</span></code> contains the subdiagonal elements of the unit lower bidiagonal
matrix <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/>.  <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.
Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.pttrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">pttrf</code><span class="sig-paren">(</span><em>d</em>, <em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pttrf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="raw-html">LDL<sup><small>T</small></sup></span>
or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization of an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> positive
definite real symmetric or complex Hermitian tridiagonal matrix
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<p>On entry, the argument <code class="docutils literal"><span class="pre">d</span></code> is a <code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> matrix with the diagonal
elements of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.  The argument <code class="docutils literal"><span class="pre">e</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">'z'</span></code> matrix containing the subdiagonal of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.  On exit
<code class="docutils literal"><span class="pre">d</span></code> contains the diagonal elements of <img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/>, and <code class="docutils literal"><span class="pre">e</span></code> contains
the subdiagonal elements of the unit lower bidiagonal matrix <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/>.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.pttrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">pttrs</code><span class="sig-paren">(</span><em>d</em>, <em>e</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/1beb2d429fd60d4494135aa7af1b4fe324dc8d3d.png" alt="AX = B"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> positive definite real
symmetric or complex Hermitian tridiagonal matrix, given its
<span class="raw-html">LDL<sup><small>T</small></sup></span>
or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization.</p>
<p>The argument <code class="docutils literal"><span class="pre">d</span></code> is the diagonal of the diagonal matrix <img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/>.
The argument <code class="docutils literal"><span class="pre">uplo</span></code> only matters for complex matrices.  If <code class="docutils literal"><span class="pre">uplo</span></code>
is <code class="xref py py-const docutils literal"><span class="pre">'L'</span></code>, then on exit <code class="docutils literal"><span class="pre">e</span></code> contains the subdiagonal elements
of the unit bidiagonal matrix <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/>.  If <code class="docutils literal"><span class="pre">uplo</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'U'</span></code>,
then <code class="docutils literal"><span class="pre">e</span></code> contains the complex conjugates of the elements of the unit
bidiagonal matrix <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/>.  On exit, <code class="docutils literal"><span class="pre">B</span></code> is overwritten with the
solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.  <code class="docutils literal"><span class="pre">B</span></code> must have the same type as <code class="docutils literal"><span class="pre">e</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="symmetric-and-hermitian-linear-equations">
<h2>Symmetric and Hermitian Linear Equations<a class="headerlink" href="#symmetric-and-hermitian-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.sysv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">sysv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>ipiv = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sysv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/1beb2d429fd60d4494135aa7af1b4fe324dc8d3d.png" alt="AX = B"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is a real or complex symmetric matrix  of order
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p>On exit, <code class="docutils literal"><span class="pre">B</span></code> is replaced by the solution.  The matrices <code class="docutils literal"><span class="pre">A</span></code> and
<code class="docutils literal"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  The
optional argument <code class="docutils literal"><span class="pre">ipiv</span></code> is an integer matrix of length at least
equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  If <code class="docutils literal"><span class="pre">ipiv</span></code> is provided, <code class="xref py py-func docutils literal"><span class="pre">sysv</span></code> solves the
system and returns the factorization in <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code>.  If
<code class="docutils literal"><span class="pre">ipiv</span></code> is not specified, <code class="xref py py-func docutils literal"><span class="pre">sysv</span></code> solves the system but does not
return the factorization and does not modify <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.sytrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">sytrf</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sytrf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization</p>
<div class="math">
<p><img src="_images/math/699d472974095e5eb4fe313c1f43831127eaaf3b.png" alt="PAP^T = LDL^T"/></p>
</div><p>of a real or complex symmetric matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p><code class="docutils literal"><span class="pre">ipiv</span></code> is an <code class="xref py py-const docutils literal"><span class="pre">'i'</span></code> matrix of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  On
exit, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> contain the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.sytrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">sytrs</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sytrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/78b84981125b77d5fbccd78772d46452501d159a.png" alt="A X = B"/></p>
</div><p>given the
<span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization computed by
<a class="reference internal" href="#cvxopt.lapack.sytrf" title="cvxopt.lapack.sytrf"><code class="xref py py-func docutils literal"><span class="pre">sytrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.sysv" title="cvxopt.lapack.sysv"><code class="xref py py-func docutils literal"><span class="pre">sysv</span></code></a>. <code class="docutils literal"><span class="pre">B</span></code> must have the same type as
<code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.sytri">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">sytri</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sytri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a real or complex symmetric matrix.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> contain the
<span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization computed by <a class="reference internal" href="#cvxopt.lapack.sytrf" title="cvxopt.lapack.sytrf"><code class="xref py py-func docutils literal"><span class="pre">sytrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.sysv" title="cvxopt.lapack.sysv"><code class="xref py py-func docutils literal"><span class="pre">sysv</span></code></a>.
On exit, <code class="docutils literal"><span class="pre">A</span></code> contains the inverse.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.hesv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">hesv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>ipiv = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hesv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/78b84981125b77d5fbccd78772d46452501d159a.png" alt="A X = B"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is a real symmetric or complex Hermitian of order
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p>On exit, <code class="docutils literal"><span class="pre">B</span></code> is replaced by the solution.  The matrices <code class="docutils literal"><span class="pre">A</span></code> and
<code class="docutils literal"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  The
optional argument <code class="docutils literal"><span class="pre">ipiv</span></code> is an integer matrix of length at least
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  If <code class="docutils literal"><span class="pre">ipiv</span></code> is provided, then <code class="xref py py-func docutils literal"><span class="pre">hesv</span></code> solves the
system and returns the factorization in <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code>.  If
<code class="docutils literal"><span class="pre">ipiv</span></code> is not specified, then <code class="xref py py-func docutils literal"><span class="pre">hesv</span></code> solves the system but does
not return the factorization and does not modify <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.hetrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">hetrf</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hetrf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization</p>
<div class="math">
<p><img src="_images/math/b4185883f66070faa34444043851101bf3e4e072.png" alt="PAP^T = LDL^H"/></p>
</div><p>of a real symmetric or complex Hermitian matrix of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.
<code class="docutils literal"><span class="pre">ipiv</span></code> is an <code class="xref py py-const docutils literal"><span class="pre">'i'</span></code> matrix of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.
On exit, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> contain the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.hetrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">hetrs</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hetrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/78b84981125b77d5fbccd78772d46452501d159a.png" alt="A X = B"/></p>
</div><p>given the
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization computed by
<a class="reference internal" href="#cvxopt.lapack.hetrf" title="cvxopt.lapack.hetrf"><code class="xref py py-func docutils literal"><span class="pre">hetrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.hesv" title="cvxopt.lapack.hesv"><code class="xref py py-func docutils literal"><span class="pre">hesv</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.hetri">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">hetri</code><span class="sig-paren">(</span><em>A</em>, <em>ipiv</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hetri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a real symmetric or complex Hermitian  matrix.</p>
<p>On entry, <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">ipiv</span></code> contain the
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization computed
by <a class="reference internal" href="#cvxopt.lapack.hetrf" title="cvxopt.lapack.hetrf"><code class="xref py py-func docutils literal"><span class="pre">hetrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.hesv" title="cvxopt.lapack.hesv"><code class="xref py py-func docutils literal"><span class="pre">hesv</span></code></a>.  On exit, <code class="docutils literal"><span class="pre">A</span></code> contains the
inverse.</p>
</dd></dl>

<p>As an example we solve the KKT system <a href="#equation-e-kkt-example">(1)</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">sysv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">[:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">m</span> <span class="p">:</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:</span><span class="n">m</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span> <span class="o">=</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sysv</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">uplo</span><span class="o">=</span><span class="s">&#39;U&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="triangular-linear-equations">
<h2>Triangular Linear Equations<a class="headerlink" href="#triangular-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.trtrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">trtrs</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em>, <em>trans = 'N'</em>, <em>diag = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.trtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a triangular set of equations</p>
<div class="math">
<p><img src="_images/math/aa6d78ef03e72bc807167e84142a6f9cf0e6860d.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is real or complex and triangular of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>,
and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> is a matrix with <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> rows.</p>
<p><code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are matrices with the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  <code class="xref py py-func docutils literal"><span class="pre">trtrs</span></code> is similar to
<a class="reference internal" href="blas.html#cvxopt.blas.trsm" title="cvxopt.blas.trsm"><code class="xref py py-func docutils literal"><span class="pre">blas.trsm</span></code></a>, except
that it raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if a diagonal element of <code class="docutils literal"><span class="pre">A</span></code>
is zero (whereas <code class="xref py py-func docutils literal"><span class="pre">blas.trsm</span></code> returns <code class="xref py py-const docutils literal"><span class="pre">inf</span></code> values).</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.trtri">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">trtri</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>uplo = 'L'</em>, <em>diag = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.trtri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a real or complex triangular matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.
On exit, <code class="docutils literal"><span class="pre">A</span></code> contains the inverse.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.tbtrs">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">tbtrs</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>uplo = 'L'</em>, <em>trans = 'T'</em>, <em>diag = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.tbtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a triangular set of equations</p>
<div class="math">
<p><img src="_images/math/aa6d78ef03e72bc807167e84142a6f9cf0e6860d.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is real or complex triangular band matrix of order
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> is a matrix with <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> rows.</p>
<p>The diagonals of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> are stored in <code class="docutils literal"><span class="pre">A</span></code> using the BLAS
conventions for triangular band matrices.  <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are
matrices with the same type (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  On exit,
<code class="docutils literal"><span class="pre">B</span></code> is replaced by the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>.</p>
</dd></dl>

</div>
<div class="section" id="least-squares-and-least-norm-problems">
<h2>Least-Squares and Least-Norm Problems<a class="headerlink" href="#least-squares-and-least-norm-problems" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.gels">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gels</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gels" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves least-squares and least-norm problems with a full rank <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>
by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">trans</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>.  If <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <code class="xref py py-func docutils literal"><span class="pre">gels</span></code> solves the least-squares problem</p>
<div class="math">
<p><img src="_images/math/d3de882a6e7d634336449ea13442b526c815a7af.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|AX-B\|_F.
\end{array}"/></p>
</div><p>If <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less than or equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <code class="xref py py-func docutils literal"><span class="pre">gels</span></code> solves
the least-norm problem</p>
<div class="math">
<p><img src="_images/math/7decdbe004c7b85da96241226ca9f150731c9365.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|X\|_F \\
\mbox{subject to} &amp; AX = B.
\end{array}"/></p>
</div></li>
<li><p class="first"><code class="docutils literal"><span class="pre">trans</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'T'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'C'</span></code> and <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are
real.  If <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>,
<code class="xref py py-func docutils literal"><span class="pre">gels</span></code> solves the least-norm problem</p>
<div class="math">
<p><img src="_images/math/19d5e95284caffb6f2733b629de62c45786b2764.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|X\|_F \\
\mbox{subject to} &amp; A^TX=B.
\end{array}"/></p>
</div><p>If <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less than or equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <code class="xref py py-func docutils literal"><span class="pre">gels</span></code> solves
the least-squares problem</p>
<div class="math">
<p><img src="_images/math/f4f7b1326f5012dac838e6664ea24caa73c10742.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|A^TX-B\|_F.
\end{array}"/></p>
</div></li>
<li><p class="first"><code class="docutils literal"><span class="pre">trans</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'C'</span></code> and <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are complex. If
<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <code class="xref py py-func docutils literal"><span class="pre">gels</span></code> solves
the least-norm problem</p>
<div class="math">
<p><img src="_images/math/cba0afcbfd537186714602299bfdbeb8006cebd6.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|X\|_F \\
\mbox{subject to} &amp; A^HX=B.
\end{array}"/></p>
</div><p>If <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less than or equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <code class="xref py py-func docutils literal"><span class="pre">gels</span></code> solves
the least-squares problem</p>
<div class="math">
<p><img src="_images/math/852a6f372bdee813bd247643f7c2c114cfcce21a.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|A^HX-B\|_F.
\end{array}"/></p>
</div></li>
</ol>
<p><code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> must have the same typecode (<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">'z'</span></code>).  <code class="docutils literal"><span class="pre">trans</span></code> = <code class="xref py py-const docutils literal"><span class="pre">'T'</span></code> is not allowed if <code class="docutils literal"><span class="pre">A</span></code> is
complex.  On exit, the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/> is stored as the leading
submatrix of <code class="docutils literal"><span class="pre">B</span></code>.  The matrix <code class="docutils literal"><span class="pre">A</span></code> is overwritten with details of
the QR or the LQ factorization of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<p>Note that <code class="xref py py-func docutils literal"><span class="pre">gels</span></code> does not check whether <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is full rank.</p>
</dd></dl>

<p>The following functions compute QR and LQ factorizations.</p>
<dl class="function">
<dt id="cvxopt.lapack.geqrf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">geqrf</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.geqrf" title="Permalink to this definition">¶</a></dt>
<dd><p>QR factorization of a real or complex matrix <code class="docutils literal"><span class="pre">A</span></code>:</p>
<div class="math">
<p><img src="_images/math/9169b2404d0208a7b57d7957672810ac001b0ead.png" alt="A = Q R."/></p>
</div><p>If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, then <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by
<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> and orthogonal/unitary, and <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and upper triangular (if <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>), or upper trapezoidal (if <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less than or
equal to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>).</p>
<p><code class="docutils literal"><span class="pre">tau</span></code>  is a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code> and of length
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.  On exit, <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is stored in the upper
triangular/trapezoidal part of <code class="docutils literal"><span class="pre">A</span></code>.  The matrix <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is stored
as a product of min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} elementary reflectors in
the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} columns of <code class="docutils literal"><span class="pre">A</span></code> and in <code class="docutils literal"><span class="pre">tau</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.gelqf">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gelqf</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gelqf" title="Permalink to this definition">¶</a></dt>
<dd><p>LQ factorization of a real or complex matrix <code class="docutils literal"><span class="pre">A</span></code>:</p>
<div class="math">
<p><img src="_images/math/a7e20a9e22ab40126649b8601c14c0c53625c1a5.png" alt="A = L Q."/></p>
</div><p>If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, then <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and orthogonal/unitary, and <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and lower triangular (if <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less than or equal to
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>), or lower trapezoidal (if <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>).</p>
<p><code class="docutils literal"><span class="pre">tau</span></code>  is a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code> and of length
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.  On exit, <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> is stored in the lower
triangular/trapezoidal part of <code class="docutils literal"><span class="pre">A</span></code>.  The matrix <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is stored
as a product of min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} elementary reflectors in the
first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} rows of <code class="docutils literal"><span class="pre">A</span></code> and in <code class="docutils literal"><span class="pre">tau</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.geqp3">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">geqp3</code><span class="sig-paren">(</span><em>A</em>, <em>jpvt</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.geqp3" title="Permalink to this definition">¶</a></dt>
<dd><p>QR factorization with column pivoting of a real or complex matrix
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>:</p>
<div class="math">
<p><img src="_images/math/72c56dc5b07da4f7d7c4d5534c1a532b8882393e.png" alt="A P = Q R."/></p>
</div><p>If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, then <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>
by <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> and orthogonal/unitary, and <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and upper triangular (if <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>), or upper trapezoidal (if <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less than or equal
to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>).</p>
<p><code class="docutils literal"><span class="pre">tau</span></code> is a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code> and of length
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.  <code class="docutils literal"><span class="pre">jpvt</span></code> is an integer matrix of
length <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  On entry, if <code class="docutils literal"><span class="pre">jpvt[k]</span></code> is nonzero, then
column <img class="math" src="_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/> of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is permuted to the front of <img class="math" src="_images/math/cd7041cd0a90f7d24f6f5c2a40216706d95858ec.png" alt="AP"/>.
Otherwise, column <img class="math" src="_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/> is a free column.</p>
<p>On exit, <code class="docutils literal"><span class="pre">jpvt</span></code> contains the permutation <img class="math" src="_images/math/f48b617185733d8dd6712643f1ab17c736661a06.png" alt="P"/>:  the operation
<img class="math" src="_images/math/cd7041cd0a90f7d24f6f5c2a40216706d95858ec.png" alt="AP"/> is equivalent to <code class="docutils literal"><span class="pre">A[:,</span> <span class="pre">jpvt-1]</span></code>.  <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> is stored
in the upper triangular/trapezoidal part of <code class="docutils literal"><span class="pre">A</span></code>.  The matrix
<img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is stored as a product of min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}
elementary reflectors in the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>,:math:<cite>n</cite>} columns
of <code class="docutils literal"><span class="pre">A</span></code> and in <code class="docutils literal"><span class="pre">tau</span></code>.</p>
</dd></dl>

<p>In most applications, the matrix <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is not needed explicitly, and
it is sufficient to be able to make products with <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> or its
transpose.  The functions <a class="reference internal" href="#cvxopt.lapack.unmqr" title="cvxopt.lapack.unmqr"><code class="xref py py-func docutils literal"><span class="pre">unmqr</span></code></a> and
<a class="reference internal" href="#cvxopt.lapack.ormqr" title="cvxopt.lapack.ormqr"><code class="xref py py-func docutils literal"><span class="pre">ormqr</span></code></a> multiply a matrix
with the orthogonal matrix computed by
<a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal"><span class="pre">geqrf</span></code></a>.</p>
<dl class="function">
<dt id="cvxopt.lapack.unmqr">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">unmqr</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>C</em><span class="optional">[</span>, <em>side = 'L'</em>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.unmqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Product with a real orthogonal or complex unitary matrix:</p>
<div class="math">
<p><img src="_images/math/b8652b0e047832222474a1e2a4ed998e75b698af.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
\begin{split}
C &amp; := \op(Q)C \quad (\mathrm{side} = \mathrm{'L'}), \\
C &amp; := C\op(Q) \quad (\mathrm{side} = \mathrm{'R'}), \\
\end{split}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/ee5608e78ca5349deca6cf03fdbdf3e278f797e0.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
\op(Q) =  \left\{ \begin{array}{ll}
    Q &amp; \mathrm{trans} = \mathrm{'N'} \\
    Q^T &amp; \mathrm{trans} = \mathrm{'T'} \\
    Q^H &amp; \mathrm{trans} = \mathrm{'C'}.
\end{array}\right."/></p>
</div><p>If <code class="docutils literal"><span class="pre">A</span></code> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, then <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is square of order
<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> and orthogonal or unitary.  <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is stored in the first
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} columns of <code class="docutils literal"><span class="pre">A</span></code> and in <code class="docutils literal"><span class="pre">tau</span></code> as a
product of min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} elementary reflectors, as
computed by <a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal"><span class="pre">geqrf</span></code></a>.
The matrices <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">tau</span></code>, and <code class="docutils literal"><span class="pre">C</span></code>
must have the same type.  <code class="docutils literal"><span class="pre">trans</span></code> = <code class="xref py py-const docutils literal"><span class="pre">'T'</span></code> is only allowed if
the typecode is <code class="xref py py-const docutils literal"><span class="pre">'d'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.ormqr">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">ormqr</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>C</em><span class="optional">[</span>, <em>side = 'L'</em>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ormqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.unmqr" title="cvxopt.lapack.unmqr"><code class="xref py py-func docutils literal"><span class="pre">unmqr</span></code></a> but works only for
real matrices, and the
possible values of <code class="docutils literal"><span class="pre">trans</span></code> are <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code> and <code class="xref py py-const docutils literal"><span class="pre">'T'</span></code>.</p>
</dd></dl>

<p>As an example, we solve a least-squares problem by a direct call to
<a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal"><span class="pre">gels</span></code></a>, and by separate calls to
<a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal"><span class="pre">geqrf</span></code></a>,
<a class="reference internal" href="#cvxopt.lapack.ormqr" title="cvxopt.lapack.ormqr"><code class="xref py py-func docutils literal"><span class="pre">ormqr</span></code></a>, and
<a class="reference internal" href="#cvxopt.lapack.trtrs" title="cvxopt.lapack.trtrs"><code class="xref py py-func docutils literal"><span class="pre">trtrs</span></code></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gels</span><span class="p">(</span><span class="o">+</span><span class="n">A</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>                  <span class="c"># x1[:n] minimizes || A*x - b ||_2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">geqrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>                 <span class="c"># A = [Q1, Q2] * [R1; 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">ormqr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>  <span class="c"># x2 := [Q1, Q2]&#39; * x2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">trtrs</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">n</span><span class="p">,:],</span> <span class="n">x2</span><span class="p">,</span> <span class="n">uplo</span><span class="o">=</span><span class="s">&#39;U&#39;</span><span class="p">)</span>  <span class="c"># x2[:n] := R1^{-1} * x2[:n]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blas</span><span class="o">.</span><span class="n">nrm2</span><span class="p">(</span><span class="n">x1</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
<span class="go">3.0050798580569307e-16</span>
</pre></div>
</div>
<p>The next two functions make products with the orthogonal matrix computed
by <a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal"><span class="pre">gelqf</span></code></a>.</p>
<dl class="function">
<dt id="cvxopt.lapack.unmlq">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">unmlq</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>C</em><span class="optional">[</span>, <em>side = 'L'</em>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.unmlq" title="Permalink to this definition">¶</a></dt>
<dd><p>Product with a real orthogonal or complex unitary matrix:</p>
<div class="math">
<p><img src="_images/math/b8652b0e047832222474a1e2a4ed998e75b698af.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
\begin{split}
C &amp; := \op(Q)C \quad (\mathrm{side} = \mathrm{'L'}), \\
C &amp; := C\op(Q) \quad (\mathrm{side} = \mathrm{'R'}), \\
\end{split}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/c96f101392de9d4e76dd0dba40750bb61a49e9a2.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
    \op(Q) =  \left\{ \begin{array}{ll}
        Q &amp; \mathrm{trans} = \mathrm{'N'}, \\
        Q^T &amp; \mathrm{trans} = \mathrm{'T'}, \\
        Q^H &amp; \mathrm{trans} = \mathrm{'C'}.
    \end{array}\right."/></p>
</div><p>If <code class="docutils literal"><span class="pre">A</span></code> is <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, then <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is square of order
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and orthogonal or unitary.  <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is stored in the first
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} rows of <code class="docutils literal"><span class="pre">A</span></code> and in <code class="docutils literal"><span class="pre">tau</span></code> as a product of
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} elementary reflectors, as computed by
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal"><span class="pre">gelqf</span></code></a>.
The matrices <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">tau</span></code>, and <code class="docutils literal"><span class="pre">C</span></code> must have the
same type.  <code class="docutils literal"><span class="pre">trans</span></code> = <code class="xref py py-const docutils literal"><span class="pre">'T'</span></code> is only allowed if the typecode
is <code class="xref py py-const docutils literal"><span class="pre">'d'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.ormlq">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">ormlq</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em>, <em>C</em><span class="optional">[</span>, <em>side = 'L'</em>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ormlq" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.unmlq" title="cvxopt.lapack.unmlq"><code class="xref py py-func docutils literal"><span class="pre">unmlq</span></code></a> but works only for
real matrices, and the
possible values of <code class="docutils literal"><span class="pre">trans</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code> and <code class="xref py py-const docutils literal"><span class="pre">'T'</span></code>.</p>
</dd></dl>

<p>As an example, we solve a least-norm problem by a direct call to
<a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal"><span class="pre">gels</span></code></a>, and by separate calls to
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal"><span class="pre">gelqf</span></code></a>,
<a class="reference internal" href="#cvxopt.lapack.ormlq" title="cvxopt.lapack.ormlq"><code class="xref py py-func docutils literal"><span class="pre">ormlq</span></code></a>,
and <a class="reference internal" href="#cvxopt.lapack.trtrs" title="cvxopt.lapack.trtrs"><code class="xref py py-func docutils literal"><span class="pre">trtrs</span></code></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gels</span><span class="p">(</span><span class="o">+</span><span class="n">A</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>                  <span class="c"># x1 minimizes ||x||_2 subject to A*x = b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gelqf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>                 <span class="c"># A = [L1, 0] * [Q1; Q2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>                           <span class="c"># x2 = [b; 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">trtrs</span><span class="p">(</span><span class="n">A</span><span class="p">[:,:</span><span class="n">m</span><span class="p">],</span> <span class="n">x2</span><span class="p">)</span>            <span class="c"># x2[:m] := L1^{-1} * x2[:m]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">ormlq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>  <span class="c"># x2 := [Q1, Q2]&#39; * x2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blas</span><span class="o">.</span><span class="n">nrm2</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Finally, if the matrix <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> is needed explicitly, it can be generated
from the output of <a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal"><span class="pre">geqrf</span></code></a> and
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal"><span class="pre">gelqf</span></code></a> using one of the following functions.</p>
<dl class="function">
<dt id="cvxopt.lapack.ungqr">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">ungqr</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ungqr" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">A</span></code> has size <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, and <code class="docutils literal"><span class="pre">tau</span></code> has length
<img class="math" src="_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/>, then, on entry, the first <code class="docutils literal"><span class="pre">k</span></code> columns of the matrix <code class="docutils literal"><span class="pre">A</span></code>
and the entries of <code class="docutils literal"><span class="pre">tau</span></code> contai an unitary or orthogonal matrix
<img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> of order <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, as computed by
<a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal"><span class="pre">geqrf</span></code></a>.  On exit,
the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} columns of <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> are contained
in the leading columns of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.orgqr">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">orgqr</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.orgqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.ungqr" title="cvxopt.lapack.ungqr"><code class="xref py py-func docutils literal"><span class="pre">ungqr</span></code></a> but works only for
real matrices.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.unglq">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">unglq</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.unglq" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal"><span class="pre">A</span></code> has size <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, and <code class="docutils literal"><span class="pre">tau</span></code> has length
<img class="math" src="_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/>, then, on entry, the first <code class="docutils literal"><span class="pre">k</span></code> rows of the matrix <code class="docutils literal"><span class="pre">A</span></code>
and the entries of <code class="docutils literal"><span class="pre">tau</span></code> contain a unitary or orthogonal matrix
<img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, as computed by
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal"><span class="pre">gelqf</span></code></a>.
On exit, the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} rows of <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/> are
contained in the leading rows of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.orglq">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">orglq</code><span class="sig-paren">(</span><em>A</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.orglq" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.unglq" title="cvxopt.lapack.unglq"><code class="xref py py-func docutils literal"><span class="pre">unglq</span></code></a> but works only for
real matrices.</p>
</dd></dl>

<p>We illustrate this with the QR factorization of the matrix</p>
<div class="math">
<p><img src="_images/math/e7d8829a559936a233a47cc7b6b40b8d04c5bd41.png" alt="A = \left[\begin{array}{rrr}
    6 &amp; -5 &amp; 4 \\ 6 &amp; 3 &amp; -4 \\ 19 &amp; -2 &amp; 7 \\ 6 &amp; -10 &amp; -5
    \end{array} \right]
  = \left[\begin{array}{cc}
    Q_1 &amp; Q_2 \end{array}\right]
    \left[\begin{array}{c} R \\ 0 \end{array}\right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">lapack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">19.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">geqrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>              <span class="c"># Upper triangular part is R.</span>
<span class="go">[-2.17e+01  5.08e+00 -4.76e+00]</span>
<span class="go">[ 2.17e-01 -1.06e+01 -2.66e+00]</span>
<span class="go">[ 6.87e-01  3.12e-01 -8.74e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q1</span> <span class="o">=</span> <span class="o">+</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">orgqr</span><span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">Q1</span><span class="p">)</span>
<span class="go">[-2.77e-01  3.39e-01 -4.10e-01]</span>
<span class="go">[-2.77e-01 -4.16e-01  7.35e-01]</span>
<span class="go">[-8.77e-01 -2.32e-01 -2.53e-01]</span>
<span class="go">[-2.77e-01  8.11e-01  4.76e-01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">orgqr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>                     <span class="c"># Q = [ Q1, Q2]</span>
<span class="go">[-2.77e-01  3.39e-01 -4.10e-01 -8.00e-01]</span>
<span class="go">[-2.77e-01 -4.16e-01  7.35e-01 -4.58e-01]</span>
<span class="go">[-8.77e-01 -2.32e-01 -2.53e-01  3.35e-01]</span>
<span class="go">[-2.77e-01  8.11e-01  4.76e-01  1.96e-01]</span>
</pre></div>
</div>
<p>The orthogonal matrix in the factorization</p>
<div class="math">
<p><img src="_images/math/3639c816d82c4273a598c5d5a8040c7290c9444f.png" alt="A = \left[ \begin{array}{rrrr}
    3 &amp; -16 &amp; -10 &amp; -1 \\
   -2 &amp; -12 &amp;  -3 &amp;  4 \\
    9 &amp;  19 &amp;   6 &amp; -6
    \end{array}\right]
  = Q \left[\begin{array}{cc} R_1 &amp; R_2 \end{array}\right]"/></p>
</div><p>can be generated as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">16.</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="p">,</span> <span class="mf">19.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.</span><span class="p">]</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">geqrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="o">+</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>                     <span class="c"># Upper trapezoidal part is [R1, R2].</span>
<span class="go">[-9.70e+00 -1.52e+01 -3.09e+00  6.70e+00]</span>
<span class="go">[-1.58e-01  2.30e+01  1.14e+01 -1.92e+00]</span>
<span class="go">[ 7.09e-01 -5.57e-01  2.26e+00  2.09e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">orgqr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="p">:</span><span class="n">m</span><span class="p">])</span>              <span class="c"># Q is in the first m columns of A.</span>
<span class="go">[-3.09e-01 -8.98e-01 -3.13e-01]</span>
<span class="go">[ 2.06e-01 -3.85e-01  9.00e-01]</span>
<span class="go">[-9.28e-01  2.14e-01  3.04e-01]</span>
</pre></div>
</div>
</div>
<div class="section" id="symmetric-and-hermitian-eigenvalue-decomposition">
<h2>Symmetric and Hermitian Eigenvalue Decomposition<a class="headerlink" href="#symmetric-and-hermitian-eigenvalue-decomposition" title="Permalink to this headline">¶</a></h2>
<p>The first four routines compute all or selected  eigenvalues and
eigenvectors of a real symmetric matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>:</p>
<div class="math">
<p><img src="_images/math/ca01cc7f3857720f5dc4b843e209e0c95830807c.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
A = V\diag(\lambda)V^T,\qquad  V^TV = I."/></p>
</div><dl class="function">
<dt id="cvxopt.lapack.syev">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">syev</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syev" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalue decomposition of a real symmetric matrix of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p><code class="docutils literal"><span class="pre">W</span></code> is a real matrix of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  On exit, <code class="docutils literal"><span class="pre">W</span></code>
contains the eigenvalues in ascending order.  If <code class="docutils literal"><span class="pre">jobz</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">'V'</span></code>, the eigenvectors are also computed and returned in <code class="docutils literal"><span class="pre">A</span></code>.
If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, the eigenvectors are not returned and the
contents of <code class="docutils literal"><span class="pre">A</span></code> are destroyed.</p>
<p>Raises an <code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code> if the eigenvalue decomposition fails.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.syevd">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">syevd</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syevd" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.syev" title="cvxopt.lapack.syev"><code class="xref py py-func docutils literal"><span class="pre">syev</span></code></a>, based
on a different
algorithm.  It is faster on large problems, but also uses more memory.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.syevx">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">syevx</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>range = 'A'</em>, <em>uplo = 'L'</em>, <em>vl = 0.0</em>, <em>vu = 0.0</em>, <em>il = 1</em>, <em>iu = 1</em>, <em>Z = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syevx" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes selected eigenvalues and eigenvectors of a real symmetric
matrix of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p><code class="docutils literal"><span class="pre">W</span></code> is a real matrix of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  On exit, <code class="docutils literal"><span class="pre">W</span></code>
contains the eigenvalues in ascending order.  If <code class="docutils literal"><span class="pre">range</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>, all the eigenvalues are computed.  If <code class="docutils literal"><span class="pre">range</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">'I'</span></code>, eigenvalues <img class="math" src="_images/math/09ed43a26043678d5a76939140100bbae8c9dd16.png" alt="i_l"/> through <img class="math" src="_images/math/e480d25b49f5eab31ed34e936f2e0103e01a819e.png" alt="i_u"/> are
computed, where <img class="math" src="_images/math/ef2b551c8cc9515c28c7517d5620b634b3b7beb6.png" alt="1 \leq i_l \leq i_u \leq n"/>.  If <code class="docutils literal"><span class="pre">range</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">'V'</span></code>, the eigenvalues in the interval <img class="math" src="_images/math/a8f6a1645b0da6b1a3e4d25495e7f11d48508cf8.png" alt="(v_l, v_u]"/> are
computed.</p>
<p>If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'V'</span></code>, the (normalized) eigenvectors are
computed, and returned in <code class="docutils literal"><span class="pre">Z</span></code>.  If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, the
eigenvectors are not computed.  In both cases, the contents of <code class="docutils literal"><span class="pre">A</span></code>
are destroyed on exit.</p>
<p><code class="docutils literal"><span class="pre">Z</span></code> is optional (and not referenced) if <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>.
It is required if <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'V'</span></code> and must have at least
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> columns if <code class="docutils literal"><span class="pre">range</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code> or <code class="xref py py-const docutils literal"><span class="pre">'V'</span></code> and  at
least <img class="math" src="_images/math/7da70b3b7d88430e05c47da4f78f6da83ee974b9.png" alt="i_u - i_l + 1"/> columns if <code class="docutils literal"><span class="pre">range</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'I'</span></code>.</p>
<p><code class="xref py py-func docutils literal"><span class="pre">syevx</span></code> returns the number of computed eigenvalues.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.syevr">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">syevr</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>range = 'A'</em>, <em>uplo = 'L'</em>, <em>vl = 0.0</em>, <em>vu = 0.0</em>, <em>il = 1</em>, <em>iu = n</em>, <em>Z =  None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syevr" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.syevr" title="cvxopt.lapack.syevr"><code class="xref py py-func docutils literal"><span class="pre">syevx</span></code></a>.
<code class="xref py py-func docutils literal"><span class="pre">syevr</span></code> is the most
recent LAPACK routine for symmetric eigenvalue problems, and expected
to supersede the three other routines in future releases.</p>
</dd></dl>

<p>The next four routines can be used to compute eigenvalues and eigenvectors
for complex Hermitian matrices:</p>
<div class="math">
<p><img src="_images/math/eb46511dbb028c937d098a05e091ad298f313e5b.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
A = V\diag(\lambda)V^H,\qquad  V^HV = I."/></p>
</div><p>For real symmetric matrices they are identical to the corresponding
<code class="xref py py-func docutils literal"><span class="pre">syev*</span></code> routines.</p>
<dl class="function">
<dt id="cvxopt.lapack.heev">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">heev</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heev" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalue decomposition of a real symmetric or complex Hermitian
matrix of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.</p>
<p>The calling sequence is identical to
<a class="reference internal" href="#cvxopt.lapack.syev" title="cvxopt.lapack.syev"><code class="xref py py-func docutils literal"><span class="pre">syev</span></code></a>,
except that <code class="docutils literal"><span class="pre">A</span></code> can be real or complex.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.heevd">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">heevd</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heevd" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.heevd" title="cvxopt.lapack.heevd"><code class="xref py py-func docutils literal"><span class="pre">heev</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.heevx">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">heevx</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>range = 'A'</em>, <em>uplo = 'L'</em>, <em>vl = 0.0</em>, <em>vu = 0.0</em>, <em>il = 1</em>, <em>iu = n</em>, <em>Z = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heevx" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes selected eigenvalues and eigenvectors of a real symmetric
or complex Hermitian matrix.</p>
<p>The calling sequence is identical to
<a class="reference internal" href="#cvxopt.lapack.syevx" title="cvxopt.lapack.syevx"><code class="xref py py-func docutils literal"><span class="pre">syevx</span></code></a>, except that <code class="docutils literal"><span class="pre">A</span></code>
can be real or complex.  <code class="docutils literal"><span class="pre">Z</span></code> must have the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.heevr">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">heevr</code><span class="sig-paren">(</span><em>A</em>, <em>W</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>range = 'A'</em>, <em>uplo = 'L'</em>, <em>vl = 0.0</em>, <em>vu = 0.0</em>, <em>il = 1</em>, <em>iu = n</em>, <em>Z = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heevr" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.heevx" title="cvxopt.lapack.heevx"><code class="xref py py-func docutils literal"><span class="pre">heevx</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="generalized-symmetric-definite-eigenproblems">
<h2>Generalized Symmetric Definite Eigenproblems<a class="headerlink" href="#generalized-symmetric-definite-eigenproblems" title="Permalink to this headline">¶</a></h2>
<p>Three types of generalized eigenvalue problems can be solved:</p>
<div class="math" id="equation-e-gevd">
<p><span class="eqno">(2)</span><img src="_images/math/040c9de764a1b5fbfc60b7b41e4d2901e5e5dd40.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\begin{split}
    AZ  &amp; = BZ\diag(\lambda)\quad \mbox{(type 1)}, \\
    ABZ &amp; = Z\diag(\lambda) \quad \mbox{(type 2)}, \\
    BAZ &amp; = Z\diag(\lambda) \quad \mbox{(type 3)},
\end{split}"/></p>
</div><p>with <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> real symmetric or complex Hermitian, and
<img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> is positive definite.  The matrix of eigenvectors is normalized
as follows:</p>
<div class="math">
<p><img src="_images/math/2cdbe3f9815dc9f57e9c461fd893d70c59432ea0.png" alt="Z^H BZ = I \quad \mbox{(types 1 and 2)}, \qquad
Z^H B^{-1}Z = I \quad \mbox{(type 3)}."/></p>
</div><dl class="function">
<dt id="cvxopt.lapack.sygv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">sygv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>W</em><span class="optional">[</span>, <em>itype = 1</em>, <em>jobz = 'N'</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sygv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the generalized eigenproblem <a href="#equation-e-gevd">(2)</a> for real symmetric
matrices of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, stored in real matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.
<code class="docutils literal"><span class="pre">itype</span></code> is an integer with possible values 1, 2, 3, and specifies
the type of eigenproblem.  <code class="docutils literal"><span class="pre">W</span></code> is a real matrix of length at least
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  On exit, it contains the eigenvalues in ascending order.
On exit, <code class="docutils literal"><span class="pre">B</span></code> contains the Cholesky factor of <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>.  If <code class="docutils literal"><span class="pre">jobz</span></code>
is <code class="xref py py-const docutils literal"><span class="pre">'V'</span></code>, the eigenvectors are computed and returned in <code class="docutils literal"><span class="pre">A</span></code>.
If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, the eigenvectors are not returned and the
contents of <code class="docutils literal"><span class="pre">A</span></code> are destroyed.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.hegv">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">hegv</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>W</em><span class="optional">[</span>, <em>itype = 1</em>, <em>jobz = 'N'</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hegv" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized eigenvalue problem <a href="#equation-e-gevd">(2)</a> of real symmetric or
complex Hermitian matrix of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  The calling sequence is
identical to <a class="reference internal" href="#cvxopt.lapack.sygv" title="cvxopt.lapack.sygv"><code class="xref py py-func docutils literal"><span class="pre">sygv</span></code></a>, except that
<code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> can be real or complex.</p>
</dd></dl>

</div>
<div class="section" id="singular-value-decomposition">
<h2>Singular Value Decomposition<a class="headerlink" href="#singular-value-decomposition" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.gesvd">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gesvd</code><span class="sig-paren">(</span><em>A</em>, <em>S</em><span class="optional">[</span>, <em>jobu = 'N'</em>, <em>jobvt = 'N'</em>, <em>U = None</em>, <em>Vt = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gesvd" title="Permalink to this definition">¶</a></dt>
<dd><p>Singular value decomposition</p>
<div class="math">
<p><img src="_images/math/40136bd3592e339b6af5c8514cf2a19d64befce6.png" alt="A = U \Sigma V^T, \qquad A = U \Sigma V^H"/></p>
</div><p>of a real or complex <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<p><code class="docutils literal"><span class="pre">S</span></code> is a real matrix of length at least min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.
On exit, its first  min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} elements are the
singular values in descending order.</p>
<p>The argument <code class="docutils literal"><span class="pre">jobu</span></code> controls how many left singular vectors are
computed.  The possible values are <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">'S'</span></code> and <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code>.  If <code class="docutils literal"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, no left
singular vectors are computed.  If <code class="docutils literal"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>, all left
singular vectors are computed and returned as columns of <code class="docutils literal"><span class="pre">U</span></code>.
If <code class="docutils literal"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'S'</span></code>, the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} left
singular vectors are computed and returned as columns of <code class="docutils literal"><span class="pre">U</span></code>.
If <code class="docutils literal"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code>, the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} left
singular vectors are computed and returned as columns of <code class="docutils literal"><span class="pre">A</span></code>.
The argument <code class="docutils literal"><span class="pre">U</span></code> is None(if <code class="docutils literal"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>) or a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>The argument <code class="docutils literal"><span class="pre">jobvt</span></code> controls how many right singular vectors are
computed.  The possible values are <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">'S'</span></code> and <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code>.  If <code class="docutils literal"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, no right
singular vectors are computed.  If <code class="docutils literal"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>, all right
singular vectors are computed and returned as rows of <code class="docutils literal"><span class="pre">Vt</span></code>.
If <code class="docutils literal"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'S'</span></code>, the first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}
right singular vectors are computed and their (conjugate) transposes
are returned as rows of <code class="docutils literal"><span class="pre">Vt</span></code>.  If <code class="docutils literal"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code>, the
first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} right singular vectors are computed
and their (conjugate) transposes are returned as rows of <code class="docutils literal"><span class="pre">A</span></code>.
Note that the (conjugate) transposes of the right singular vectors
(i.e., the matrix <img class="math" src="_images/math/c983ed273b9536c28bbff3ab1a32c2458c70fe22.png" alt="V^H"/>) are returned in <code class="docutils literal"><span class="pre">Vt</span></code> or <code class="docutils literal"><span class="pre">A</span></code>.
The argument <code class="docutils literal"><span class="pre">Vt</span></code> can be <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (if <code class="docutils literal"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>) or a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>On exit, the contents of <code class="docutils literal"><span class="pre">A</span></code> are destroyed.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.lapack.gesdd">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gesdd</code><span class="sig-paren">(</span><em>A</em>, <em>S</em><span class="optional">[</span>, <em>jobz = 'N'</em>, <em>U = None</em>, <em>Vt = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gesdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Singular value decomposition of a real or complex <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> by
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrix..  This function is based on a divide-and-conquer
algorithm and is faster than <a class="reference internal" href="#cvxopt.lapack.gesdd" title="cvxopt.lapack.gesdd"><code class="xref py py-func docutils literal"><span class="pre">gesvd</span></code></a>.</p>
<p><code class="docutils literal"><span class="pre">S</span></code> is a real matrix of length at least min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>}.
On exit, its first min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} elements are the
singular values in descending order.</p>
<p>The argument <code class="docutils literal"><span class="pre">jobz</span></code> controls how many singular vectors are computed.
The possible values are <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>, <code class="xref py py-const docutils literal"><span class="pre">'S'</span></code> and
<code class="xref py py-const docutils literal"><span class="pre">'O'</span></code>.  If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>, no singular vectors are
computed.  If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code>, all <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> left singular
vectors are computed and returned as columns of <code class="docutils literal"><span class="pre">U</span></code> and all
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> right singular vectors are computed and returned as rows of
<code class="docutils literal"><span class="pre">Vt</span></code>.  If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'S'</span></code>, the first
min{<img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>} left and right singular vectors are computed
and returned as columns of <code class="docutils literal"><span class="pre">U</span></code> and rows of <code class="docutils literal"><span class="pre">Vt</span></code>.
If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code> and <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, the first <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> left singular vectors are returned as
columns of <code class="docutils literal"><span class="pre">A</span></code> and the <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> right singular vectors are returned
as rows of <code class="docutils literal"><span class="pre">Vt</span></code>.  If <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code> and <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is less
than <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, the <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> left singular vectors are returned as
columns of <code class="docutils literal"><span class="pre">U</span></code> and the first <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> right singular vectors are
returned as rows of <code class="docutils literal"><span class="pre">A</span></code>.  Note that the (conjugate) transposes of
the right singular vectors are returned in <code class="docutils literal"><span class="pre">Vt</span></code> or <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>The argument <code class="docutils literal"><span class="pre">U</span></code> can be <code class="xref py py-const docutils literal"><span class="pre">None</span></code> (if <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code> of <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code> and <img class="math" src="_images/math/c4bb40dd65eae6c11b325989b14e0b8d35e4e3ef.png" alt="m"/> is greater
than or equal to  <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>)  or a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code>.
The argument <code class="docutils literal"><span class="pre">Vt</span></code> can be None(if <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal"><span class="pre">'A'</span></code> or <code class="docutils literal"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal"><span class="pre">'O'</span></code> and :math`m` is less than
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>) or a matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>On exit, the contents of <code class="docutils literal"><span class="pre">A</span></code> are destroyed.</p>
</dd></dl>

</div>
<div class="section" id="schur-and-generalized-schur-factorization">
<h2>Schur and Generalized Schur Factorization<a class="headerlink" href="#schur-and-generalized-schur-factorization" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cvxopt.lapack.gees">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gees</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>w = None</em>, <em>V = None</em>, <em>select = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gees" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Schur factorization</p>
<div class="math">
<p><img src="_images/math/d758b8f7ecd9593ebd41b06fde3fa0bbb1dd86f6.png" alt="A = V S V^T \quad \mbox{($A$ real)}, \qquad
A = V S V^H \quad \mbox{($A$ complex)}"/></p>
</div><p>of a real or complex <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.</p>
<p>If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is real, the matrix of Schur vectors <img class="math" src="_images/math/c99df7a209495334da442b1ec998abaabfa320d8.png" alt="V"/> is
orthogonal, and <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> is a real upper quasi-triangular matrix with
1 by 1 or 2 by 2 diagonal blocks.  The 2 by 2 blocks correspond to
complex conjugate pairs of eigenvalues of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.
If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is complex, the matrix of Schur vectors <img class="math" src="_images/math/c99df7a209495334da442b1ec998abaabfa320d8.png" alt="V"/> is
unitary, and <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> is a complex upper triangular matrix with the
eigenvalues of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> on the diagonal.</p>
<p>The optional argument <code class="docutils literal"><span class="pre">w</span></code> is a complex matrix of length at least
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  If it is provided, the eigenvalues of <code class="docutils literal"><span class="pre">A</span></code> are returned
in <code class="docutils literal"><span class="pre">w</span></code>.  The optional argument <code class="docutils literal"><span class="pre">V</span></code> is an <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>
matrix of the same type as <code class="docutils literal"><span class="pre">A</span></code>.  If it is provided, then the Schur
vectors are returned in <code class="docutils literal"><span class="pre">V</span></code>.</p>
<p>The argument <code class="docutils literal"><span class="pre">select</span></code> is an optional ordering routine.  It must be a
Python function that can be called as <code class="docutils literal"><span class="pre">f(s)</span></code> with a complex
argument <code class="docutils literal"><span class="pre">s</span></code>, and returns <code class="xref py py-const docutils literal"><span class="pre">True</span></code> or <code class="xref py py-const docutils literal"><span class="pre">False</span></code>.  The
eigenvalues for which <code class="docutils literal"><span class="pre">select</span></code> returns <code class="xref py py-const docutils literal"><span class="pre">True</span></code> will be selected
to appear first along the diagonal.  (In the real Schur factorization,
if either one of a complex conjugate pair of eigenvalues is selected,
then both are selected.)</p>
<p>On exit, <code class="docutils literal"><span class="pre">A</span></code> is replaced with the matrix <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/>.  The function
<code class="xref py py-func docutils literal"><span class="pre">gees</span></code> returns an integer equal to the number of eigenvalues
that were selected by the ordering routine.  If <code class="docutils literal"><span class="pre">select</span></code> is
<code class="xref py py-const docutils literal"><span class="pre">None</span></code>, then <code class="xref py py-func docutils literal"><span class="pre">gees</span></code> returns 0.</p>
</dd></dl>

<p>As an example we compute the complex Schur form of the matrix</p>
<div class="math">
<p><img src="_images/math/49e9bad6f3f8925a19802b447eb5f47a1351aaf3.png" alt="A = \left[\begin{array}{rrrrr}
    -7 &amp;  -11 &amp; -6  &amp; -4 &amp;  11 \\
     5 &amp;  -3  &amp;  3  &amp; -12 &amp; 0 \\
    11 &amp;  11  &amp; -5  &amp; -14 &amp; 9 \\
    -4 &amp;   8  &amp;  0  &amp;  8 &amp;  6 \\
    13 &amp; -19  &amp; -12 &amp; -8 &amp; 10
    \end{array}\right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">13.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="o">-</span><span class="mf">19.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="p">],</span>
<span class="go">                [-4., -12., -14., 8., -8.], [11., 0., 9., 6., 10.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gees</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[ 5.67e+00+j1.69e+01 -2.13e+01+j2.85e+00  1.40e+00+j5.88e+00 -4.19e+00+j2.05e-01  3.19e+00-j1.01e+01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  5.67e+00-j1.69e+01  1.09e+01+j5.93e-01 -3.29e+00-j1.26e+00 -1.26e+01+j7.80e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  1.27e+01+j3.43e-17 -6.83e+00+j2.18e+00  5.31e+00-j1.69e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -1.31e+01-j0.00e+00 -2.60e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -7.86e+00-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">[ 5.67e+00+j1.69e+01]</span>
<span class="go">[ 5.67e+00-j1.69e+01]</span>
<span class="go">[ 1.27e+01+j3.43e-17]</span>
<span class="go">[-1.31e+01-j0.00e+00]</span>
<span class="go">[-7.86e+00-j0.00e+00]</span>
</pre></div>
</div>
<p>An ordered Schur factorization with the eigenvalues in the left half of
the complex plane ordered first, can be computed as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gees</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">select</span> <span class="o">=</span> <span class="n">F</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[-1.31e+01-j0.00e+00 -1.72e-01+j7.93e-02 -2.81e+00+j1.46e+00  3.79e+00-j2.67e-01  5.14e+00-j4.84e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00 -7.86e+00-j0.00e+00 -1.43e+01+j8.31e+00  5.17e+00+j8.79e+00  2.35e+00-j7.86e-01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  5.67e+00+j1.69e+01 -1.71e+01-j1.41e+01  1.83e+00-j4.63e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  5.67e+00-j1.69e+01 -8.75e+00+j2.88e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  1.27e+01+j3.43e-17]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">[-1.31e+01-j0.00e+00]</span>
<span class="go">[-7.86e+00-j0.00e+00]</span>
<span class="go">[ 5.67e+00+j1.69e+01]</span>
<span class="go">[ 5.67e+00-j1.69e+01]</span>
<span class="go">[ 1.27e+01+j3.43e-17]</span>
</pre></div>
</div>
<dl class="function">
<dt id="cvxopt.lapack.gges">
<code class="descclassname">cvxopt.lapack.</code><code class="descname">gges</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>a = None</em>, <em>b = None</em>, <em>Vl = None</em>, <em>Vr = None</em>, <em>select = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gges" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized Schur factorization</p>
<div class="math">
<p><img src="_images/math/e3be8b9772729b304adf47f411e4ac8d7e4ab48a.png" alt="A = V_l S V_r^T, \quad B = V_l T V_r^T \quad
    \mbox{($A$ and $B$ real)},

A = V_l S V_r^H, \quad B = V_l T V_r^H, \quad
    \mbox{($A$ and $B$ complex)}"/></p>
</div><p>of a pair of real or complex <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrices
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>, <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>.</p>
<p>If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> are real, then the matrices of left and
right Schur vectors <img class="math" src="_images/math/310ff53034c8c54d1df11297464404d37dae8616.png" alt="V_l"/> and <img class="math" src="_images/math/ef12b38f8dd041b3da4503cfb9e2c1c3d38a0486.png" alt="V_r"/> are orthogonal,
<img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> is a real upper quasi-triangular matrix with 1 by 1 or 2 by
2 diagonal blocks, and <img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> is a real triangular matrix with
nonnegative diagonal.  The 2 by 2 blocks along the diagonal of
<img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> correspond to complex conjugate pairs of generalized
eigenvalues of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>, <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/>.  If <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> are
complex, the matrices of left and right Schur vectors <img class="math" src="_images/math/310ff53034c8c54d1df11297464404d37dae8616.png" alt="V_l"/> and
<img class="math" src="_images/math/ef12b38f8dd041b3da4503cfb9e2c1c3d38a0486.png" alt="V_r"/> are unitary, <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> is complex upper triangular, and
<img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/> is complex upper triangular with nonnegative real diagonal.</p>
<p>The optional arguments <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are <code class="xref py py-const docutils literal"><span class="pre">'z'</span></code> and
<code class="xref py py-const docutils literal"><span class="pre">'d'</span></code> matrices of length at least <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  If these are
provided, the generalized eigenvalues of <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code> are returned in
<code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>.  (The generalized eigenvalues are the ratios
<code class="docutils literal"><span class="pre">a[k]</span> <span class="pre">/</span> <span class="pre">b[k]</span></code>.)  The optional arguments <code class="docutils literal"><span class="pre">Vl</span></code> and <code class="docutils literal"><span class="pre">Vr</span></code> are
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> by <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> matrices of the same type as <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code>.
If they are provided, then the left Schur vectors are returned in
<code class="docutils literal"><span class="pre">Vl</span></code> and the right Schur vectors are returned in <code class="docutils literal"><span class="pre">Vr</span></code>.</p>
<p>The argument <code class="docutils literal"><span class="pre">select</span></code> is an optional ordering routine.  It must be
a Python function that can be called as <code class="docutils literal"><span class="pre">f(x,y)</span></code> with a complex
argument <code class="docutils literal"><span class="pre">x</span></code> and a real argument <code class="docutils literal"><span class="pre">y</span></code>, and returns <code class="xref py py-const docutils literal"><span class="pre">True</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">False</span></code>.  The eigenvalues for which <code class="docutils literal"><span class="pre">select</span></code> returns
<code class="xref py py-const docutils literal"><span class="pre">True</span></code> will be selected to appear first on the diagonal.
(In the real Schur factorization, if either one of a complex conjugate
pair of eigenvalues is selected, then both are selected.)</p>
<p>On exit, <code class="docutils literal"><span class="pre">A</span></code> is replaced with the matrix <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> and <code class="docutils literal"><span class="pre">B</span></code> is
replaced with the matrix <img class="math" src="_images/math/6d42c88506b8da39a2a23653aecbfb7c29728063.png" alt="T"/>.  The function <code class="xref py py-func docutils literal"><span class="pre">gges</span></code> returns
an integer equal to the number of eigenvalues that were selected by
the ordering routine.  If <code class="docutils literal"><span class="pre">select</span></code> is <code class="xref py py-const docutils literal"><span class="pre">None</span></code>, then
<code class="xref py py-func docutils literal"><span class="pre">gges</span></code> returns 0.</p>
</dd></dl>

<p>As an example, we compute the generalized complex Schur form of the
matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> of the previous example, and</p>
<div class="math">
<p><img src="_images/math/a263cf4c66f239a6fc0fb13bdd3c5233766186ae.png" alt="B = \left[\begin{array}{ccccc}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{array}\right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">13.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="o">-</span><span class="mf">19.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="p">],</span>
<span class="go">                [-4., -12., -14., 8., -8.], [11., 0., 9., 6., 10.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[:</span><span class="mi">19</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gges</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[ 6.64e+00-j8.87e+00 -7.81e+00-j7.53e+00  6.16e+00-j8.51e-01  1.18e+00+j9.17e+00  5.88e+00-j4.51e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  8.48e+00+j1.13e+01 -2.12e-01+j1.00e+01  5.68e+00+j2.40e+00 -2.47e+00+j9.38e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -1.39e+01-j0.00e+00  6.78e+00-j0.00e+00  1.09e+01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -6.62e+00-j0.00e+00 -2.28e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -2.89e+01-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[ 6.46e-01-j0.00e+00  4.29e-01-j4.79e-02  2.02e-01-j3.71e-01  1.08e-01-j1.98e-01 -1.95e-01+j3.58e-01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  8.25e-01-j0.00e+00 -2.17e-01+j3.11e-01 -1.16e-01+j1.67e-01  2.10e-01-j3.01e-01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  7.41e-01-j0.00e+00 -3.25e-01-j0.00e+00  5.87e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  8.75e-01-j0.00e+00  4.84e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[ 6.64e+00-j8.87e+00]</span>
<span class="go">[ 8.48e+00+j1.13e+01]</span>
<span class="go">[-1.39e+01-j0.00e+00]</span>
<span class="go">[-6.62e+00-j0.00e+00]</span>
<span class="go">[-2.89e+01-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[ 6.46e-01]</span>
<span class="go">[ 8.25e-01]</span>
<span class="go">[ 7.41e-01]</span>
<span class="go">[ 8.75e-01]</span>
<span class="go">[ 0.00e+00]</span>
</pre></div>
</div>
</div>
<div class="section" id="example-analytic-centering">
<h2>Example: Analytic Centering<a class="headerlink" href="#example-analytic-centering" title="Permalink to this headline">¶</a></h2>
<p>The analytic centering problem is defined as</p>
<div class="math">
<p><img src="_images/math/4a82b599d0a030a9cabfc00f731fbc8471d90e9a.png" alt="\begin{array}{ll}
    \mbox{minimize} &amp; -\sum\limits_{i=1}^m \log(b_i-a_i^Tx).
\end{array}"/></p>
</div><p>In the code below we solve the problem using Newton&#8217;s method.  At each
iteration the Newton direction is computed by solving a positive definite
set of linear equations</p>
<div class="math">
<p><img src="_images/math/016add6975e83d6df1ea24466c468d0f712c4da5.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\newcommand{\ones}{\mathbf 1}
A^T \diag(b-Ax)^{-2} A v = -\diag(b-Ax)^{-1}\ones"/></p>
</div><p>(where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> has rows <img class="math" src="_images/math/0672fed1fee7fb053d48c4f52b9a0adbb8e28419.png" alt="a_i^T"/>), and a suitable step size is
determined by a backtracking line search.</p>
<p>We use the level-3 BLAS function <a class="reference internal" href="blas.html#cvxopt.blas.syrk" title="cvxopt.blas.syrk"><code class="xref py py-func docutils literal"><span class="pre">blas.syrk</span></code></a> to
form the Hessian
matrix and the LAPACK function <a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal"><span class="pre">posv</span></code></a> to
solve the Newton system.
The code can be further optimized by replacing the matrix-vector products
with the level-2 BLAS function <a class="reference internal" href="blas.html#cvxopt.blas.gemv" title="cvxopt.blas.gemv"><code class="xref py py-func docutils literal"><span class="pre">blas.gemv</span></code></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">acent</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the analytic center of A*x &lt;= b.</span>
<span class="sd">    We assume that b &gt; 0 and the feasible set is bounded.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MAXITERS</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">ALPHA</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">BETA</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">TOL</span> <span class="o">=</span> <span class="mf">1e-8</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">MAXITERS</span><span class="p">):</span>

        <span class="c"># Gradient is g = A^T * (1./(b-A*x)).</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**-</span><span class="mi">1</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">d</span>

        <span class="c"># Hessian is H = A^T * diag(d)^2 * A.</span>
        <span class="n">Asc</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span> <span class="n">d</span><span class="p">[:,</span><span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">A</span> <span class="p">)</span>
        <span class="n">blas</span><span class="o">.</span><span class="n">syrk</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>

        <span class="c"># Newton step is v = -H^-1 * g.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span>
        <span class="n">lapack</span><span class="o">.</span><span class="n">posv</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c"># Terminate if Newton decrement is less than TOL.</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">blas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">lam</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TOL</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span>

        <span class="c"># Backtracking line search.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="o">-</span><span class="n">step</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">step</span> <span class="o">*=</span> <span class="n">BETA</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">step</span><span class="o">*</span><span class="n">y</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">ALPHA</span><span class="o">*</span><span class="n">step</span><span class="o">*</span><span class="n">lam</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="n">BETA</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">*</span><span class="n">v</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="fftw.html" class="btn btn-neutral float-right" title="Discrete Transforms">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="blas.html" class="btn btn-neutral" title="The BLAS Interface"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="copyright.html">Copyright</a> .
      Last updated on Sep 21, 2015.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.1.8',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>

</body>
</html>